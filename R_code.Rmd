---
title: "Mood"
author: "Arda Ergin"
date: "2024-04-02"
output: html_document
---

# Setup
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(patchwork)
library(scales)
library(lubridate)
```

```{r}
data_raw <- read.csv("data.csv")
```


How many variables and how many participants?
```{r}
unique(data_raw$variable)
unique(data_raw$id)
```

Some Quick Fixes:
```{r}
##### ID #####
# Getting a better ID column:
data_0 <- data_raw %>%
  mutate(ID = as.numeric(sapply(
    strsplit(id, split = '\\.'), function(x) x[2])))
# Factorizing the ID variable
data_0$ID <- factor(data_0$ID)

##### "X" #####
# Changing the name for the "X" variable
colnames(data_0)[1] <- "obs_number"


# Getting rid of the id variable
data_1 <- data_0[,c("obs_number", "time", "ID", "variable", "value")]
```

fixing time
```{r}
# Checking if there is any NAs in the `time` variable
any(is.na(data_1$time))

# Transforming the variable into an time variable:
data_1 <- data_1 %>% mutate(
  date_time = as.POSIXct(
    as.character(time), 
    format="%Y-%m-%d %H:%M:%OS"))
data_2 <- subset(data_1, select = -time)

# Quick Summary
summary(data_2$date_time)
```

Long to Wide Transformation:
```{r}
wide_data <- tidyr::pivot_wider(
  data_1, 
  names_from = variable, 
  values_from = value)

data <- as.data.frame(wide_data)
```

Looking at Just one Individual
```{r}
data_id_1 <- data %>% filter(ID == 1)
```





# Investigating Variables
## (ALL) Checking Range
```{r}
for(i in 1:ncol(data)){
  cat("\n=========\n")
  cat(colnames(data)[i])
  cat("\n=========\n")
  print(summary(data[,i]))
}
```

Based on these, cleaning the necessary data:
```{r}
# Taking a look at the problematic data
problematic <- data %>% filter(appCat.builtin < 0)
problematic

# Filtering these 3 responses 
data_cleaner <- data %>% filter(appCat.builtin >= 0 | is.na(appCat.builtin))
data <- data_cleaner
```


## Mood
```{r}
# Quick Summary
summary(wide_data$mood)
table(wide_data$mood)

# Histogram
data %>% ggplot(aes(x = mood)) + 
  geom_histogram(bins = 10, color = "black", fill = "firebrick") +
  theme_classic(base_family = "Times") + 
  labs(title = "Distribution of Mood Observations", 
       x = "Mood", 
       y = "Frequency")
```

```{r}
mood_summary <- data %>%
  group_by(ID) %>%
  summarise(mean_mood = mean(mood, na.rm = TRUE),
            median_mood = median(mood, na.rm = TRUE),
            sd_mood = sd(mood, na.rm = TRUE),
            max_mood = max(mood, na.rm = TRUE),
            min_mood = min(mood, na.rm = TRUE))
mood_summary
```

Important the understand our DV, so good to summarize is for each participant.        
- Overall, there does not seem to be much of a difference between the individuals in terms of their mean and median.
- On the other hand, mood fluctuations are not the same for all individuals, and there might be individuals who experience more fluctuations.

```{r}
for (participant in unique(data$ID)) {
  moods <- data %>%
    filter(!is.na(mood))
  
  mood <- moods %>% filter(ID == participant)
  
  p <- mood %>% ggplot(
    aes(x = date_time, 
        y = mood)) +
    geom_line(color = colors()[sample(8:length(colors()),1)]) + 
    scale_y_continuous(limits = c(1, 10)) +
    theme_classic(base_family = "Times") + 
    theme(legend.position = "none") +
    labs(title = paste(
      "Mood Over Time for Participant Number", 
      participant), 
         x = "Time", 
         y = "Mood")
  
  print(p)
}
```

Participant number 7 have too much fluctuations and can be considered an outlier among the other participants. It might possibly be a good idea to exclude them. Maybe also participant number 33.

```{r}
# Creating a new variable in our "mood_summary" 
# Putting the ID to the column if the participant is an outlier 
# FROM: https://www.r-bloggers.com/2022/08/how-to-label-outliers-in-boxplots-in-ggplot2/
find_outlier <- function(x) {
  return(x < quantile(x, .25) - 1.5*IQR(x) | x > quantile(x, .75) + 1.5*IQR(x))
}

mood_summary <- mood_summary %>%
  mutate(outlier = ifelse(find_outlier(sd_mood), ID, NA))

mood_summary %>% ggplot(aes(x = "", y = sd_mood)) +
  geom_boxplot(color = "firebrick") +
  theme_classic() +
  labs(title = "Boxplot of Standard Deviation of Mood",
       y = "Standard Deviation of Mood",
       x = "") + 
  geom_text(aes(label=outlier), na.rm=TRUE, hjust=-1)
```

Although, it needs to be noted that individuals who have depression will show these mood fluctuations. If we assume that this sample is a representative sample, considering the $10-20\%$ prevalence, we should expect around $2-4$ individuals that are displaying such patterns. Hence, it is a question whether this should actually be considered as an "anomaly". 



## Arousal & Valence
```{r}
# Quick Summary: Arousal
summary(data$circumplex.arousal)
table(data$circumplex.arousal)

# Quick Summary: Valence
summary(data$circumplex.valence)
table(data$circumplex.valence)

# Histograms & Combining Them
hist_arousal <- data %>% ggplot(aes(x = circumplex.arousal)) + 
  geom_histogram(bins = 5, color = "black", fill = "deepskyblue2") +
  theme_classic(base_family = "Times") + 
  labs(title = "Distribution of Arousal", 
       x = "Arousal", 
       y = "Frequency")

hist_valence <- data %>% ggplot(aes(x = circumplex.valence)) + 
  geom_histogram(bins = 5, color = "black", fill = "purple2") +
  theme_classic(base_family = "Times") + 
  labs(title = "Distribution of Valence", 
       x = "Valence", 
       y = "Frequency")

# Doing layout for ggpplot2:
(hist_arousal | hist_valence) + 
  patchwork::plot_layout(ncol = 2)
```



## Time

### New Variables
```{r}
# Creating Variable: the Date (of Observation)
data <- data %>%
  mutate(date = as.Date(date_time))

# Creating Variable: the Time (of Observation)
data <- data %>%
  mutate(time = format(date_time, "%H:%M:%S"))

# Creating Variable: the Hour (of Observation)
data <- data %>%
  mutate(hour = format(date_time, "%H"))
data$hour <- as.numeric(data$hour)

# Creating Variable: the day of the week (of Observation)
data <- data %>%
  mutate(weekday = weekdays(date_time),
         weekday = factor(
           weekday, 
           levels = c("Monday", "Tuesday", 
                      "Wednesday", "Thursday", 
                      "Friday", "Saturday", 
                      "Sunday")))

# Creating Variable: the week of the year (of Observation)
data <- data %>%
  mutate(week_of_year = lubridate::week(date_time))
```


### Visual: Entire Time
```{r}
length(unique(data$date))
# Histogram
data %>% ggplot(aes(x = date)) + 
  geom_histogram(bins = 112, 
                 color = "black", 
                 fill = "purple2") +
  theme_classic(base_family = "Times") + 
  labs(title = "Distribution of Observations", 
       x = "Date-Time", 
       y = "Frequency") + scale_x_date(breaks = "1 week",date_labels = "%d-%m")
```

### Visual: Hour x Observ.
```{r}
data %>% ggplot(aes(x = hour)) + 
  geom_histogram(bins = 24, 
                 color = "black", 
                 fill = "purple2") + 
  theme_classic(base_family = "Times") + 
  labs(title = "Frequency of Observations Per Hour", 
       x = "Hour",
       y = "Frequency") + 
  scale_x_continuous(breaks = 0:23)
```

### Visual: Hour x Activity

```{r}
# Summarizing Per Weekday
hour_activity <- data %>%
  group_by(hour) %>%
  summarise(
    mean_act = mean(activity, na.rm = TRUE),
    sd_act = sd(activity, na.rm = TRUE),
    n = sum(!is.na(activity)),
    sem = sd_act / sqrt(n),
    ci_lower = mean_act - qnorm(0.975) * sem,
    ci_upper = mean_act + qnorm(0.975) * sem
  )

# Bar Plot
hour_activity %>%
  ggplot(aes(
    x = hour, 
    y = mean_act)) + 
  geom_col(color = "black", 
           fill = "skyblue1") +
  geom_errorbar(aes(ymin = ci_lower, 
                    ymax = ci_upper), 
                width = .2) + 
  theme_classic(base_family = "Times") +
  labs(
    title = "Mean Activity per Hour",
    x = "Hour",
    y = "Mean Activity"
  )
```


### Visual: Weekdays
```{r}
# Summarizing Per Weekday
weekday_summary <- data %>%
  group_by(weekday) %>%
  summarise(
    mean_mood = mean(mood, na.rm = TRUE),
    sd_mood = sd(mood, na.rm = TRUE),
    n = sum(!is.na(mood)),
    sem = sd_mood / sqrt(n),
    ci_lower = mean_mood - qnorm(0.975) * sem,
    ci_upper = mean_mood + qnorm(0.975) * sem
  )

# Bar Plot
weekday_summary %>%
  ggplot(aes(
    x = weekday, 
    y = mean_mood)) + 
  geom_col(color = "black", 
           fill = "skyblue1") +
  geom_errorbar(aes(ymin = ci_lower, 
                    ymax = ci_upper), 
                width = .2) +  
  geom_text(aes(
    label = paste("n =", n), 
    y = mean_mood + 0.02), 
    vjust = -5.5,
    family = "Times New Roman") + 
  theme_classic(base_family = "Times") +
  labs(
    title = "Mean Mood per Weekday",
    x = "Weekday",
    y = "Mean Mood"
  ) + 
  coord_cartesian(ylim = c(6.8,7.5))
```


### Visual: Week of Year
```{r}
# Summarizing Per Weekday
week_summary <- data %>%
  group_by(week_of_year) %>%
  summarise(
    mean_mood = mean(mood, na.rm = TRUE),
    sd_mood = sd(mood, na.rm = TRUE),
    n = sum(!is.na(mood)),
    sem = sd_mood / sqrt(n),
    ci_lower = mean_mood - qnorm(0.975) * sem,
    ci_upper = mean_mood + qnorm(0.975) * sem
  )

# Bar Plot
week_summary %>%
  ggplot(aes(
    x = week_of_year, 
    y = mean_mood)) + 
  geom_col(color = "black", 
           fill = "skyblue") +
  geom_errorbar(aes(ymin = ci_lower, 
                    ymax = ci_upper), 
                width = .2) +  
  geom_text(aes(
    label = n, 
    y = mean_mood + 0.02), 
    vjust = -10,
    family = "Times New Roman") + 
  theme_classic(base_family = "Times") +
  labs(
    title = "Mean Mood per Week of the Year",
    x = "Week of the Year",
    y = "Mean Mood"
  ) + 
  coord_cartesian(ylim = c(6,7.6))
  
```



### *** Filtering Time ***

```{r}
table(data$date)
# 2014-03-13 or 2014-03-20
# 2014-05-29 or 2014-05-05
```



```{r}
# A bit more conservative: 
data_filter_time <- data %>% filter(date > "2014-03-13" & date < "2014-05-29")
# > 4000
data_filter_time_2 <- data %>% filter(date > "2014-03-20" & date < "2014-05-05")
```


```{r}
data_filter_time_2 %>% ggplot(aes(x = date)) + 
  geom_histogram(bins = length(unique(data_filter_time_2$date)), 
                 color = "black", 
                 fill = "purple2") +
  theme_classic(base_family = "Times") + 
  labs(title = "Distribution of Observations over Time", 
       x = "Date-Time", 
       y = "Frequency") + 
  scale_x_date(
    breaks = seq(as.Date("2014-03-21"), 
                 as.Date("2014-05-04"), 
                 by = "1 day"), 
    date_labels = "%d-%m") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
data <- data_filter_time_2
```


# Fixing Days

## Observation Day
```{r}
# Adding a days_since_start column
data <- data %>% mutate(
  days_since_start = as.numeric(
    difftime(date, min(date), units = "days")))

# Check
unique(data$days_since_start)
```


## Taking a Look at Activity
```{r}
activity_count_per_hour <- data_filter_time_2 %>%
  filter(!is.na(activity)) %>%
  group_by(hour) %>%
  summarize(count = n())

# Bar Plot
activity_count_per_hour %>%
  ggplot(aes(
    x = hour, 
    y = count)) + 
  geom_col(color = "black", 
           fill = "orange") + coord_cartesian(ylim=c(700,900))
```


```{r}
activity_count_per_hour <- data_filter_time_2 %>%
  filter(activity == 0) %>%
  group_by(hour) %>%
  summarize(count = n())

# Bar Plot
activity_count_per_hour %>%
  ggplot(aes(
    x = hour, 
    y = count)) + 
  geom_col(color = "black", 
           fill = "orange")
```


```{r}
data <- x
```


## Trials
```{r}
# Sort data by date_time
data <- data %>% arrange(ID, date_time)

# Flagging inactive periods potentially indicating sleep
data <- data %>% mutate(
  is_inactive = dplyr::case_when(
    is.na(activity) ~ FALSE,
    activity == 0 ~ TRUE,
    TRUE ~ FALSE),
  potential_sleep_hour = (hour >= 20 | hour <= 10))
```


```{r}
# Column for the time difference between 
# the current observation and the last observation
data <- data %>%
  group_by(ID) %>%
  mutate(
    time_diff = round(
      difftime(date_time, 
               lag(date_time),
               units = "hours"),3)) %>%
  ungroup()
```


```{r}

```















```{r}
data <- data %>%
  mutate(
    changed = is_inactive & (hour >= 20 | hour <= 10),  # Update the condition as needed
    change_id = cumsum(changed != lag(changed, default = first(changed)))  # Detect changes to start new blocks
  ) %>%
  group_by(ID, change_id) %>%
  mutate(
    block_duration = n(),  # Count observations per block
    block_start = min(days_since_start),  # Get the start time of the block
    block_end = max(days_since_start)  # Get the end time of the block
  ) %>%
  ungroup()
```





```{r}
data$days_since_start
# Assuming the data is already loaded and the columns 'is_inactive' and 'potential_sleep_block' have been set
data <- data %>%
  mutate(
    changed = is_inactive & (hour >= 20 | hour <= 10),  # Update the condition as needed
    change_id = cumsum(changed != lag(changed, default = first(changed)))  # Detect changes to start new blocks
  ) %>%
  group_by(ID, change_id) %>%
  mutate(
    block_duration = n(),  # Count observations per block
    block_start = min(days_since_start),  # Get the start time of the block
    block_end = max(days_since_start)  # Get the end time of the block
  ) %>%
  ungroup()
```












## Stuff




```{r}
id_1 <- playaround_2 %>% filter(ID == 1)
```

```{r}
playaround <- data_filter_time_2
```


```{r}
# Sort data by date_time
playaround <- playaround %>% arrange(date_time)

# Identify inactive periods by creating a binary column for activity
data$is_inactive <- as.integer(
  data$activity == 0)

# Differentiate consecutive periods of inactivity
data$inactive_block <- with(
  rle(data$is_inactive), 
  rep(seq_along(lengths), lengths))

# Calculate the duration of each inactive period
sleep_periods <- playaround %>%
  filter(is_inactive == 1) %>%
  group_by(inactive_block) %>%
  summarise(sleep_start = min(date_time), 
            sleep_end = max(date_time), 
            inactive_hours = n()) %>%
  filter(inactive_hours > 5) # Considering only periods longer than 5 hours

# Filter for sleep periods between 8 PM and 10 AM
sleep_periods <- sleep_periods %>%
  filter(hour(sleep_start) >= 20 | hour(sleep_end) <= 10)

# Merge sleep periods back to the main data to identify relevant observations
playaround_2 <- left_join(
  playaround, 
  sleep_periods, 
  by = "inactive_block")

# Create 'observation_day' by adjusting the date based on sleep periods
playaround_2$observation_day <- ifelse(
  as.Date(playaround_2$date_time) < as.Date(playaround_2$sleep_end) & !is.na(playaround_2$sleep_end),
  as.Date(playaround_2$date_time) - days(1),
  as.Date(playaround_2$date_time)
)

# Clean up the data frame by removing unnecessary columns
# participant_data <- participant_data %>% select(-c(inactive_block, is_inactive))

# View adjusted data
# head(participant_data)
```



```{r}
play_2 <- data_filter_time_2
```


```{r}
# Identify periods of inactivity (assuming zero activity indicates inactivity)
data$is_inactive <- data$activity == 0

# Determine the start of a potential sleep block
data$potential_sleep_block <- data$is_inactive & (data$hour >= 20 | play_2$hour <= 10)




# Calculate the start and end times of sleep blocks
play_2 <- play_2 %>%
  group_by(grp = cumsum(!potential_sleep_block)) %>%
  mutate(sleep_start = ifelse(any(is_inactive), 
                              first(date_time[is_inactive]), NA),
         sleep_end = ifelse(any(is_inactive), last(date_time[is_inactive]), NA)) %>%
  ungroup() %>%
  select(-grp)

# Assuming the experiment starts at midnight of the first recorded date
experiment_start <- as.Date(min(participant_data$date_time))

# Calculate the observation day based on the time and sleep blocks
participant_data$observation_day <- as.Date(participant_data$date_time)
for(i in 1:nrow(participant_data)) {
  if(!is.na(participant_data$sleep_end[i]) && participant_data$date_time[i] <= participant_data$sleep_end[i]) {
    participant_data$observation_day[i] <- as.Date(participant_data$sleep_start[i]) - days(1)
  } else {
    participant_data$observation_day[i] <- as.Date(participant_data$date_time[i])
  }
}

# This will now give you a column with the adjusted observation day
head(participant_data)

```



```{r}


play_3 <- data_filter_time_2

# Convert date_time to datetime object
is(play_3$date_time) <- ymd_hms(play_3$date_time)

# Create a new column to indicate if the person is asleep (activity = 0)
data$asleep <- ifelse(data$activity == 0, 1, 0)

# Determine the sleep blocks using rle (run length encoding)
sleep_blocks <- rle(data$asleep)

# Filter only the blocks where asleep == 1 and the length of the block is greater than 5
sleep_periods <- which(sleep_blocks$values == 1 & sleep_blocks$lengths > 5)

# Get the start times of these sleep periods
sleep_start_times <- cumsum(c(1, sleep_blocks$lengths))[sleep_periods]

# Adjust the dates based on these sleep start times
data$day_of_observation <- data$date_time

for (i in sleep_start_times) {
  # The observations from the start of the sleep period back to the start of the day are considered the previous day
  data$day_of_observation[(i-1):(i-6)] <- data$date_time[(i-1):(i-6)] - days(1)
}

# Now, you can use day_of_observation for your analyses

```




```{r}
# Adjusting the 'awake_day' for times after midnight but part of a sleep session
df$awake_day <- as.Date(df$date_time)  # Create an initial awake_day column

# Function to adjust dates based on sleep periods
adjust_dates <- function(row, sleep_blocks) {
  for (i in 1:nrow(sleep_blocks)) {
    if (row$date_time >= sleep_blocks$start_time[i] && row$date_time <= sleep_blocks$end_time[i] && hour(row$date_time) < 4) {
      return(as.Date(row$date_time) - days(1))
    }
  }
  return(as.Date(row$date_time))
}

# Apply the adjustment
df$awake_day <- apply(df, 1, adjust_dates, sleep_blocks)

```




# Aggregating

We have a couple of options

The most straightforward one (and kind of bad):
```{r}
# aggregating the data by date, for all participants
new_data <- data_filter_time %>%
  group_by(date, ID) %>%
  summarise(
    variable_mean = mean(mood, na.rm = TRUE),
    circumplex.arousal = mean(circumplex.arousal, na.rm = TRUE),
    circumplex.valence = mean(circumplex.valence, na.rm = TRUE),
    activity = mean(activity, na.rm = TRUE),
    # screen???
    call = sum(call, na.rm = TRUE),
    sms = sum(sms, na.rm = TRUE),
    appCat.builtin = sum(appCat.builtin, na.rm = TRUE),
    appCat.communication = sum(appCat.communication, na.rm = TRUE),
    appCat.entertainment = sum(appCat.entertainment, na.rm = TRUE),
    appCat.finance = sum(appCat.finance, na.rm = TRUE),
    appCat.game = sum(appCat.game, na.rm = TRUE),
    appCat.office = sum(appCat.office, na.rm = TRUE),
    appCat.other = sum(appCat.other, na.rm = TRUE),
    appCat.social = sum(appCat.social, na.rm = TRUE),
    appCat.travel = sum(appCat.travel, na.rm = TRUE),
    appCat.unknown = sum(appCat.unknown, na.rm = TRUE),
    appCat.utilities = sum(appCat.utilities, na.rm = TRUE), 
    appCat.weather = sum(appCat.weather, na.rm = TRUE), 
    .groups = "drop")

```


## New Variable: Time of Observation
```{r}
a <- data %>% 
  mutate(
    adjusted_date_time = if_else(
      hour(date_time) < 4, date_time - days(1), date_time),
    adjusted_date = as.Date(adjusted_date_time)
  )

# Group by participant and adjusted_date to find the last observation for each day
a <- a %>%
  group_by(id, adjusted_date) %>%
  mutate(last_observation_time = max(date_time)) %>%
  ungroup()


x_2 <- x %>% filter(date == "2014-02-26")
```


```{r}

dataa <- data %>% filter(is.na(activity))

dataa <- dataa %>%
  arrange(ID, date_time) %>%
  group_by(ID) %>%
  mutate(
    time_diff = lead(date_time) - date_time
  ) %>%
  ungroup()


dataa <- dataa %>%
  mutate(
    is_sleep_start = if_else(
      time_diff >= hours(6), TRUE, FALSE, missing = FALSE))

id_1 <- dataa %>% filter(ID == 1)

```









