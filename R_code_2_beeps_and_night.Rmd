---
title: "Mood"
author: "Arda Ergin"
date: "2024-04-02"
output: html_document
---

```{r}
source("requirements.R")
load("R_code_1.RData")
```


# Adding Beeps

First assigning new rows with beeps to the dataset.
```{r}
# Generate additional times and beeps
additional_times <- c(
  "06:00:01", # ghost beep to mark night time
  "09:00:01", 
  "12:00:01", 
  "15:00:01", 
  "18:00:01", 
  "21:00:01")
beep_identifiers <- c(0, 1, 2, 3, 4, 5) 
dates <- unique(as.Date(data$date_time))
participants <- unique(data$ID)

# Map times to beep identifiers
time_to_beep <- setNames(beep_identifiers, additional_times)
# Create a data frame of all combinations of dates, times, and participants
expanded_data <- expand.grid(
  date = dates, 
  time = additional_times, 
  ID = participants)
expanded_data$date_time <- as.POSIXct(paste(
  expanded_data$date, 
  expanded_data$time))
expanded_data$beep_number <- time_to_beep[as.character(expanded_data$time)]

# Initialize columns for expanded_data that are in data but not in expanded_data
additional_columns <- setdiff(names(data), names(expanded_data))
for (col in additional_columns) {
  expanded_data[[col]] <- NA
}

# Combine original and expanded data
data$beep_number <- NA # since this variable does not exist in the original dataset
combined_data <- rbind(data, expanded_data)

# Remove duplicate rows and sort by date_time
combined_data <- combined_data %>%
  arrange(ID, date_time) %>%
  distinct()

# Make sure it is sorted by ID and date_time
combined_data <- combined_data %>%
  arrange(ID, date_time)

# Fill beep_number NA values using zoo::na.locf()
combined_data$beepo <- zoo::na.locf(
  combined_data$beep_number, 
  na.rm = FALSE, 
  fromLast = TRUE)

### THE OTHER WAY:: ###
#combined_data$beepo2 <- zoo::na.locf(
#  combined_data$beep_number, 
#  na.rm = FALSE)
```

Cleaning the beeps that are NA:
```{r}
source("start_end_dates.R")
combined_data_clean <- clean_id_time(combined_data)
```

Creating an **OBSERVATION DAY VARIABLE BASED ON ID**
```{r}
# Create a flag that identifies each transition from beep 5 to beep 0
combined_data_clean <- combined_data_clean %>%
  group_by(ID) %>% mutate(
    new_day_flag = if_else(lag(beepo, default = first(beepo)) == 5 & beepo == 0, 1, 0),
    # Cumulatively sum these flags to identify unique observation days for each participant
    observation_day = cumsum(new_day_flag)) %>%
  ungroup()
```

Removing the observation day 0, since it is incomplete (missing some of the night-time). Not really ideal, the previous day could have been used and completed, but I really could not bother with it.
```{r}
combined_data_clean_removed_obs_day_0 <- combined_data_clean %>% 
  filter(observation_day != 0) %>% subset(select = -new_day_flag)
```


# Creating Sleep

```{r}
data_beepo_0 <- combined_data_clean_removed_obs_day_0 %>% filter(
  beepo == 0 | (time == "21:00:01" & is.na(obs_number)))
```


```{r}
# Sort data by date_time
data_beepo_0 <- data_beepo_0 %>% arrange(ID, date_time)
```


## Potential Sleep Gap
```{r}
# Column for the time difference between 
# the current observation and the last observation
data_beepo_0 <- data_beepo_0 %>% 
  group_by(ID, observation_day) %>% mutate(
  # For every observation, getting the difference between the previous
  time_diff = round(
    difftime(date_time, lag(date_time),
             units = "hours"), 3),
  # If it is 15, then make it 9, for looking at sleep later
  time_diff_adj = ifelse(time_diff == 15, 0, time_diff),
  # Gap based on both these variables
  possible_sleep_gap = (time_diff_adj > 1 & time_diff_adj <= 9),
  time_diff_valid = ifelse(
    possible_sleep_gap, time_diff_adj, 0)
  ) %>% 
  ungroup()
```

## Inactivity

```{r}
# Inactivity
data_beepo_0 <- data_beepo_0 %>% mutate(
  is_inactive = dplyr::case_when(
    is.na(activity) ~ FALSE,
    activity == 0 ~ TRUE,
    TRUE ~ FALSE))

# Applying a run-length encoding to count consecutive inactive periods
data_beepo_0 <- data_beepo_0 %>% group_by(ID) %>% mutate(
    consecutive_inactive = with(rle(is_inactive), {
      # Only count lengths where is_inactive is TRUE:
      lengths_corrected <- lengths * values  
      # Repeat these lengths according to run lengths:
      rep(lengths_corrected, lengths)   
    })) %>% 
  ungroup()

# Getting rid of the consequitve duplicates so that summing up later is easier.
data_beepo_0 <- data_beepo_0 %>%
  mutate(
    # Use lag to compare each value to the previous, 
    # initializing the first comparison to TRUE
    consecutive_inactive_fix = if_else(
      consecutive_inactive != lead(
        consecutive_inactive, 
        default = consecutive_inactive[n()]+1), 
      (consecutive_inactive - 1), 0),
    
    consecutive_inactive_fix = if_else(
      consecutive_inactive_fix == -1,
      0,
      consecutive_inactive_fix)
  )

table(data_beepo_0$consecutive_inactive_fix)
```

## Aggregating Night Data
```{r}
aggregated_night_data <- data_beepo_0 %>%
  group_by(ID, observation_day) %>%
  summarise(
    night_mood = safe_mean(mood),
    night_arousal = safe_mean(circumplex.arousal),
    night_valence = safe_mean(circumplex.valence),
    
    night_physical_activity = safe_mean(activity),
    
    night_screen = sum(screen, na.rm = T),
    
    night_appcat_combined = sum(
      appCat.builtin,
      appCat.communication,
      appCat.entertainment,
      appCat.finance,
      appCat.game,
      appCat.office,
      appCat.other,
      appCat.social,
      appCat.travel,
      appCat.unknown,
      appCat.utilities,
      appCat.weather, na.rm = T),
    
    total_time_diff = safe_sum(time_diff_valid),
    max_time_diff = max(time_diff_valid, na.rm = T),
    
    total_inactivity = safe_sum(consecutive_inactive_fix),
    max_inactivity = max(consecutive_inactive_fix, na.rm = T),
    
    SUM_inactivity_timediff = sum(
      total_inactivity, 
      total_time_diff, 
      na.rm = T),
    
    MAX_inactivity_timediff = max(
      max_time_diff, 
      max_inactivity, 
      na.rm = T),
    .groups = "drop")
```


# Aggregating Data on Beeps
```{r}
aggregated_data <- combined_data_clean_removed_obs_day_0 %>%
  group_by(ID, observation_day, beepo) %>%
  summarise(
    date = max(date),
    mood = mean(mood, na.rm = TRUE),
    arousal = mean(circumplex.arousal, na.rm = TRUE),
    valence = mean(circumplex.valence, na.rm = TRUE),
    activity = mean(activity, na.rm = TRUE),
    screen = sum(screen, na.rm = TRUE),
    call = sum(call, na.rm = TRUE),
    sms = sum(sms, na.rm = TRUE),
    appCat.builtin = sum(appCat.builtin, na.rm = TRUE),
    appCat.communication = sum(appCat.communication, na.rm = TRUE),
    appCat.entertainment = sum(appCat.entertainment, na.rm = TRUE),
    appCat.finance = sum(appCat.finance, na.rm = TRUE),
    appCat.game = sum(appCat.game, na.rm = TRUE),
    appCat.office = sum(appCat.office, na.rm = TRUE),
    appCat.other = sum(appCat.other, na.rm = TRUE),
    appCat.social = sum(appCat.social, na.rm = TRUE),
    appCat.travel = sum(appCat.travel, na.rm = TRUE),
    appCat.unknown = sum(appCat.unknown, na.rm = TRUE),
    appCat.utilities = sum(appCat.utilities, na.rm = TRUE), 
    appCat.weather = sum(appCat.weather, na.rm = TRUE), 
    .groups = "drop")
```

## Adding Night
```{r}
data_with_night <- aggregated_data %>%
  left_join(aggregated_night_data, by = c("ID", "observation_day")) %>% 
  filter(beepo != 0)
```

## Night-mood Replace
```{r}
data_with_night <- data_with_night %>%
  arrange(ID, observation_day, beepo) %>%
  group_by(ID) %>% mutate(
    # Create lagged versions of night variables to fill backwards
    lead_night_mood = if_else(
      beepo == 5, 
      lead(night_mood, default = first(night_mood)), 
      NA_real_),
    
    lead_night_arousal = if_else(
      beepo == 5, 
      lead(night_arousal, default = first(night_arousal)),
      NA_real_),
    
    lead_night_valence = if_else(
      beepo == 5, 
      lead(night_valence, default = first(night_valence)), 
      NA_real_)) %>% ungroup()

data_with_night <- data_with_night %>% mutate(
    mood = case_when(
      beepo == 5 & is.na(mood) ~ lead_night_mood,
      beepo == 5 & !is.na(mood) & !is.na(lead_night_mood) ~ 
        (mood + lead_night_mood)/2,
      TRUE ~ mood
    ),
    arousal = case_when(
      beepo == 5 & is.na(arousal) ~ lead_night_arousal,
      beepo == 5 & !is.na(arousal) & !is.na(lead_night_arousal) ~ 
        (arousal + lead_night_arousal)/2,
      TRUE ~ arousal
    ),
    valence = case_when(
      beepo == 5 & is.na(valence) ~ lead_night_valence,
      beepo == 5 & !is.na(valence) & !is.na(lead_night_valence) ~ 
        (valence + lead_night_valence)/2,
      TRUE ~ valence)
    )
```



```{r}
data <- data_with_night
```


choosing night variables and some cleaning 
```{r}
data <- data %>% subset(
  select = -c(night_mood, night_arousal, night_valence,
              total_time_diff, max_time_diff, 
              total_inactivity, max_inactivity, 
              lead_night_mood, lead_night_arousal, lead_night_valence))

# Creating Variable: the day of the week (of Observation)
data <- data %>%
  mutate(weekday = weekdays(date),
         weekday = as.numeric(factor(
           weekday,
           labels = 1:7,
           levels = c("Monday", "Tuesday", 
                      "Wednesday", "Thursday", 
                      "Friday", "Saturday", 
                      "Sunday"))))

# Creating Variable: the week of the year (of Observation)
data <- data %>%
  mutate(week_of_year = lubridate::week(date))
```


```{r}
save(data, file = "R_code_2.RData")
```


